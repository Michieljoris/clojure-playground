
* to run cider add this file:
** ~/.lein/profiles.clj
{:user {:plugins [[cider/cider-nrepl "0.8.0-SNAPSHOT"]]}}
and make sure 0.8.0-SNAPSHOT matches cider version.
* start cider:
cider-mode
cider-jackin
* keybindings
** cider 
C-c M-n	Switch to namespace of the current buffer
C-x C-e	Evaluate the expression immediately preceding point
C-c C-k	Compile current buffer
C-, save and compile
C-M-x eval outer sexpr
** paredit
M-x paredit-mode	Toggle paredit mode
M-(	paredit-wrap-round, surround expression after point in parentheses
C-→	Slurp; move closing parenthesis to the right to include next expression
C-←	Barf; move closing parenthesis to the left to exclude last expression
C-M-f, C-M-b	Move to the opening/closing parenthesis


* clojure
 zeal: clojure:defn
 http://clojuredocs.org/quickref 
http://java.ociweb.com/mark/clojure/article.html
** datatypes
lists(), vectors [], maps {}, sets #{}
#"regular-expression"
"string"
\newline \space \uunicode-hex-value
:keyword
^{key-value-pairs} object (metadata)

many functions will call seq on a collection argument before doing anything
else. 
(map inc [1 2 3])
; => (2 3 4)
- into and conj:
 one takes a rest-param (conj) and one takes a seqable data structure (into).
- apply "explodes" a seqable data structure so that it can be passed to a
  function which expects a rest-param
  
** functions
(defn
a-name
"(Optional) a docstring"
[Parameters]
(The function body)
)
*** anonymous
(#(* % 3) 8)
 macros
** reader-macros 
Clojure code consists of textual representations of data structures called
reader forms. You'll notice that all your code that actually does stuff —
function calls, if's, def's, etc — consists of list reader forms.

The reader transforms these reader forms into the actual internal data
structures.
** evaluation   
-  Strings, numbers, characters, true, false, nil and keywords evaluate to
  themselves
-  a symbol resolves to either a special form or a value
-  the data structure is an empty list, it evaluates to an empty list:
   Otherwise, it is a call to the first element of the list: which is a special
   form or a function call or a macro
   
so normally:
text -> reader -> datastructure -> evaluator -> value 
but when evaluating a macro call:
text -> reader -> datastructure -> macroexpander -> new-datastructure ->
evaluator -> value

** protocols
** multimethods
** core.typed
** core.async   
